From the beginning our goal was to create a GPU framework like \cite{macklin2014unified} supporting simulation of many different elements, e.g. fluids, cloth and rigid bodies. Therefore we started of studying how Position-Based Dynamics worked in general. When we had an understanding of what we would need to do in order to achieve our goal we decided to start implementing prototype applications solving the constraints we were interested in. The selected constraints were shape matching constraints for rigid and deformable bodies and density constraints for fluids. 

These prototypes had simulations running in 2D and were made single threaded to allow more convenient debugging on the CPU. However as the project progressed and when we were about to make the switch to the GPU we decided to narrow our scope. Hence our focus shifted into solely develop a fluid simulation running on the GPU in 3D.

We first had a stint working with OpenCL and OpenGL interoperability. But after a longer break we decided to make the switch to CUDA and OpenGL interoperability instead. This as we were keen on using CUDA \textit{Surfaces} which are textures that can be both written and read during the same kernel run.


\subsection{Algorithm overview}

The three dimensional Position Based Dynamics fluid simulation implementation we have made is inspired by both \cite{macklin2013position} and \cite{macklin2014unified}. Our implementation is based upon two types of constraints, collision and density. A brief outline of the implementation is presented in Algorithm \ref{alg:overview}.

\begin{algorithm}
\caption{Outline of a simulation step}
\label{alg:overview}
\begin{algorithmic}[1]
\small

\For{$i$ : $numberOfParticles$}
\State Apply forces: $\mathbf{v}_{i} = \mathbf{v}_{i} + (\mathbf{f}_{gravity} + \mathbf{f}_{i_{vorticity}})\Delta t$
\State Predict position: $\mathbf{x}_{i}^{*}= \mathbf{x}_{i} + \mathbf{v}_{i} \Delta t$
\State Confine particle to box, adjust $\mathbf{x}_{i}$, $\mathbf{x}_{i}^{*}$ and $\mathbf{v}_{i}$ 
\EndFor


\For{$i$ : $numberOfParticles$}
\State Compute cell id $h_{i}$ by utilization of Z-order hashing
\EndFor

\State Sort particles in increasing $h$

\State Reorder all textures and buffers according to sorted ordering

\State Compute $cellStarts$ and $cellEndings$ for all cells containing particles


\For{$i$ : $numberOfParticles$}
\State Find neighbouring particles $N_{i}(\mathbf{x}_{i}^{*})$ used by collision and density constraints
\EndFor

\While{$solverIteration$ $<$ $numberOfSoverIterations$}
\For{$i$ : $numberOfParticles$}
\State Compute lambda $\lambda_{i}$
\EndFor
\For{$i$ : $numberOfParticles$}
\State Compute delta position $\Delta \mathbf{x}_{i}^{*}$
\EndFor
\While{$stabilizationIteration$ $<$ $numberOfStabilizationIterations$}
\State Solve collision constraints, update both $\mathbf{x}$ and $\mathbf{x}^{*}$
\EndWhile
\For{$i$ : $numberOfParticles$}
\State Apply delta position: $\mathbf{x}_{i}^{*} = \mathbf{x}_{i}^{*} + \Delta \mathbf{x}_{i}^{*}$
\EndFor
\EndWhile
\For{$i$ : $numberOfParticles$}
\State Update velocity: $\mathbf{v}_{i} = \frac{(\mathbf{x}_{i}^{*} - \mathbf{x}_{i})}{\Delta t}$
\State Update position: $\mathbf{x}_{i} = \mathbf{x}_{i}^{*}$
\EndFor
\For{$i$ : $numberOfParticles$}
\State Compute omegas $\mathbf{\Omega}_{i}$ to be used for computation of vorticity and viscosity
\EndFor
\For{$i$ : $numberOfParticles$}
\State Compute vorticity $\mathbf{f}_{i_{vorticity}}$
\EndFor
\For{$i$ : $numberOfParticles$}
\State Compute and apply viscosity: $\mathbf{v}_{i} = \mathbf{v}_{i} + \mathbf{v}_{viscosity}$
\EndFor

\end{algorithmic}
\end{algorithm}


\subsection{Collision}
Something \cite{bullet} \cite{radix}

\subsection{Rendering}

