\subsection{Position-Based Dynamics}
\input{tex/theory/pbd.tex}

\subsection{Collision between particles}

The collision constraint between two particles $ \mathbf{x}_{i} $ and $ \mathbf{x}_{j} $ is formulated by Equation \ref{eq:collisionConstraint}, where the radius of each particle is $ r $. It is commonly solved by translating each particle away from one another along the line $ \| \mathbf{x}_{ij} \| $.

\begin{equation} \label{eq:collisionConstraint}
  C(\mathbf{x}_{i}, \mathbf{x}_{j}) = \| \mathbf{x}_{ij} \| - r \geq 0
\end{equation}

Solving collision constraints between particles by brute force is a very time consuming process, $\mathcal{O}(n^{2})$. As of such developers often look at smarter ways of solving collisions between particles. Due to the fact that particles and other objects for that matter only interact in small regions it is well suited to look at methods involving spatial subdivisions.

\subsubsection{Uniform grid}

One such method that also performs well and is easy to parallelize is the use of a \textit{Uniform Grid} \cite{Green}. A uniform grid implies that the world is composed of a number of cells in a cubical grid, where each cell can store particles. If the cell width equals the diameter of a particle (under the assumption that all particles have the same diameter) collisions only occur between particles of neighbouring cells. This means that only 27 cells per particle needs to be considered in a three dimensional space if the particle collisions are to be solved in a particle based manner. This type of grid is also convenient when solving fluid constraints that originates from the ideas behind \textit{Smoothed-Particle Hydrodynamics} (SPH), as those require all neighbouring particles within a certain distance (defined by the kernel width of \textit{Spiky} and \textit{Poly} kernels).

\subsubsection{Collision with objects}

By transforming the geometry of an object to a particle representation and adding shape matching constraints too hold the particles together one can also have collisions with arbitrary objects \cite{muller2005meshless, macklin2014unified}. The process of creating a particle representation of an object is called \textit{Voxelization} and there exist various methods for achieving this, e.g. \cite{VoxPolygon, VoxSingle}. Some methods build \textit{Occtrees} to be be used for querying occupied \textit{Voxels} while other methods derive the particle representation from \textit{Ray-casting} \cite{VoxSingle}. Performance wise it is suitable to perform the Voxelization of objects prior to the start of the simulation.


\subsection{Density}

The estimation of the predicted position of the particles is initially based on solving a density constraint $C$ in (REF NIKLAS?). Where each density constraint is applied per particle. The density constraint is a function of the position of the current particle and the positions of its neighbours within a fixed radius. For each particle \textit{i}, the applied density constraint is defined as equation \ref{eq:Ci}

\begin{equation}
\label{eq:Ci}
C_i(\hat{\mathbf{p}}) = \frac{\rho_i}{\rho_0} - 1,
\end{equation}
\\
where $\hat{\mathbf{p}}$ contains the positions of the neighbouring particles, $\rho_0$ is the fluid's rest density and $\rho_i$ is estimated by the density SPH estimator:

\begin{equation}
\label{eq:Rhoi}
\rho_i = \sum\limits_{j} m_j W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

In this particular case, where all particles have equal mass, the mass parameter $m_j$ can be removed from $\ref{eq:Rhoi}$. What is left is a sum of density kernels $W$, also called \textit{Poly6}, see \cite{macklin2013position}. Where $W$ is a kernel function with the parameters; the position of the current particle  $i$, neighbouring positions $j$ and a fixed radius $h$.
\\
The next term to be solved from equation (NIKLAS REF?) is $\nabla C$. It is done by following \cite{macklin2013position} approach and has two different outcomes based on whenever particle $k$ is a neighbouring particle or not:
\\
\begin{equation}
 \nabla \mathbf{p}_k C_i = \frac{1}{\rho_0}
  \begin{cases}
  \label{eq:NablaC}
   \displaystyle \sum\limits_{j} \nabla \mathbf{p}_k W(\mathbf{p}_i - \mathbf{p}_j, h) & $\text{if }$ k = i \\
   - \nabla \mathbf{p}_k W(\mathbf{p}_i - \mathbf{p}_j, h) & $\text{if }$ k = j \\
  \end{cases}
\end{equation}
\\
With \ref{eq:Ci} and \ref{eq:NablaC} it is now possible to determine $\lambda$ from equation (NIKLAS REF?):

\begin{equation}
\label{eq:Lambda}
\lambda_i = \frac{- C_i(\hat{\mathbf{p}}) }{ \sum\limits_{k} |\nabla \mathbf{p}_k C_i|^2 }.
\end{equation}
\\
As seen in $\cite{macklin2013position}$, we can observe that this is not stable when the particles are at the boundary of the smoothing kernel, mainly because of the denominator with the exponents in the kernel function. Therefore a user specified relaxation parameter, $\varepsilon$, is added to (NIKLAS REF?) to add constraint force. The modified version of $\ref{eq:Lambda}$ is given by
\begin{equation}
\label{eq:LambdaEpsilon}
\lambda_i = \frac{- C_i(\hat{\mathbf{p}}) }{ \sum\limits_{k} |\nabla \mathbf{p}_k C_i|^2 + \varepsilon}.
\end{equation}
We can now include $\lambda_j$ from the neighbouring particles in the estimation of the final position update, $\Delta \mathbf{p}$, given by

\begin{equation}
\label{eq:DeltaP}
\Delta \mathbf{p}_i = \frac{1}{\rho_0} \sum\limits_{j} (\lambda_i + \lambda_j) \nabla W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

\subsection{Tensile instability}
We continue to follow the theory at \cite{macklin2013position}, by adding an artificial pressure to reduce unwanted particle behaviour. The negative pressure tends to result into particle clustering and sometimes hard coupling, which is a common problem in SPH simulations. The trick is therefore to force the pressure to be non-negative, with following drawback; a reduction of the particles' cohesiveness. The artificial pressure force is described as
\\
\begin{equation}
\label{eq:Scorr}
s_{corr} = -k \left( \frac{W(\mathbf{p}_i - \mathbf{p}_j, h)}{W(\Delta \mathbf{q}, h)} \right),
\end{equation}
\\
where $\Delta \mathbf{q}$ is a point with a fixed distance inside the kernel radius and k is a small positive constant. This term is then included in equation $\ref{eq:DeltaP}$ and the final version is updated to 

\begin{equation}
\label{eq:DeltaPscorr}
\Delta \mathbf{p} = \frac{1}{\rho_0} \sum\limits_{j} (\lambda_i + \lambda_j + s_{corr}) \nabla W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

\subsection{Vorticity confinement and Viscosity}
We add lost energy, called vorticity, to compensate the lost turbulent motion in our simulation, see \cite{macklin2013position}. 
Firstly, the vorticity, which defines the curl of the local vector field at the current particle's location, is calculated by using SPH kernel function

\begin{equation}
\label{eq:Omega}
\omega_{i} = \nabla \times \mathbf{v} =  \sum\limits_{j} \mathbf{v}_{ij} \times \nabla_{\mathbf{p}_{j}} W(\mathbf{p}_{i} - \mathbf{p}_{j}, h),
\end{equation}
where $\mathbf{v}_{ij} = \mathbf{v}_{j} - \mathbf{v}_{i}$. Then we use the location vector $\mathbf{N} = \frac{\eta}{|\eta|}$, with $\eta = \nabla|\omega|_{i}$
, which will have a direction from areas with low vorticity towards areas containing high vorticity. The resulting vorticity force is defined by
\\
\begin{equation}
\label{eq:Vorticity}
\mathbf{f}_{i}^{vorticity} = \varepsilon \left(\mathbf{N} \times \omega_{i} \right).
\end{equation}
\\
The viscocity is also added to the velocity vector field as a force, the term will control the fluid's consistency and is calculated as 
\begin{equation}
\label{eq:Viscosity}
\mathbf{v}_{i}^{new} = \mathbf{v}_{i} + c \sum\limits_{j} \mathbf{v}_{ij} \cdot W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

\subsection{Shape matching}

To simulate shape matching and elastic behaviour the initial physical properties of the deformable
object must be stored. There are no need for any connection information, since the positions and the velocities of the particles 
are updated without any computation of internal constraint. Instead, defined goal positions are determined by matching the shape of the deformed 
object and the shape of the initial object. For each time step all particles are pulled towards their goal positions.

\subsubsection{Goal positions}
The goal positions are obtained when the best transformation is determined that matches the set of initial positions 
$\mathbf{\hat{x}}$ and the set of deformed positions reffered as $\mathbf{x}$. As seen in $\cite{bender2014muller}$, we aim to minimize the transformation matrix, 
which is described as a composition of a rotation matrix 
and translation vectors. The corresponding roation matrix $\mathbf{R}$ and the translational vectors
$\mathbf{\hat{c}}$ and $\mathbf{c}$ are determined by minimizing 

\begin{equation}
\label{eq:MinR}
\sum\limits_{i} w_{i}\left(\mathbf{R}(\mathbf{\hat{x}}_{i} - \mathbf{\hat{c}}) + \mathbf{c} - \mathbf{x}_{i} \right)^{2},
\end{equation}
\\
where $w_{i}$ is the weigth of individual points. The optimal translation vectors are given by the centre of mass of the initial shape and the centre of mass
of the deformed shape. They are defined as

\begin{equation}
\label{eq:TransVec}
\mathbf{\hat{c}} = \frac{1}{M} \sum\limits_{i} m_{i}\mathbf{\hat{x}}_{i} , \indent
\mathbf{c} = \frac{1}{M} \sum\limits_{i} m_{i}\mathbf{x}_{i} , \indent
M = \sum\limits_{i} m_{i} 
\end{equation}
\\
By minimizing the term $\sum\limits_{i} (\mathbf{A}\mathbf{\hat{r}}_{i} - \mathbf{r}_{i})^2$ with $ \mathbf{r}_{i} = \mathbf{x}_{i} - 
\mathbf{c}$ and $\mathbf{\hat{r}}_{i} = \mathbf{\hat{x}}_{i} - \mathbf{\hat{c}} $, we get the optimal linear transformation $\mathbf{A}$
of the initial and deformed shape. This transformation is therefore determined by

\begin{equation}
\label{eq:A}
\mathbf{A} = \left(\sum\limits_{i} m_{i}\mathbf{r}\mathbf{\hat{r}}^{T}_{i} \right) \left(\sum\limits_{i} m_{i}\mathbf{\hat{r}}\mathbf{\hat{r}}^{T}_{i} \right)
= \mathbf{A}_{r}\mathbf{A}_{s}.
\end{equation}
\\
In equation $\ref{eq:A}$ we are interested in the rotational part of the transformation. We only need to determine the rotational part of 
$\mathbf{A}_{r}$, since $\mathbf{A}_{s}$ is symmetric. To obtain the optimal rotation $\mathbf{R}$ a polar decomposition of $\mathbf{A}_{r}$ is done; $\mathbf{A}_{r} = \mathbf{R}\mathbf{S}$, where $\mathbf{S}$ is a symmetric matrix.
We can now determine the goal positions by the definition

\begin{equation}
\label{eq:G}
\mathbf{g}_{i} = \left[ \mathbf{R}(\mathbf{c} - \mathbf{R}\mathbf{\hat{c}}) \right] 
    \begin{bmatrix}
       \mathbf{\hat{x}}_{i} \\[0.3em]
       1 
    \end{bmatrix},
\end{equation}
Finally, the position corrections can be computed by 

\begin{equation}
\label{eq:DeltaX}
\Delta \mathbf{x}_{i} = \alpha(\mathbf{g}_{i} - \mathbf{x}_{i}(t)),
\end{equation}
where $\alpha \in [0, 1]$ is a user specified stiffness parameter that describes by how much the particle will be pulled towards their goal positions.

