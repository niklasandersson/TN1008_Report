\subsection{Position-Based Dynamics}
\input{tex/theory/pbd.tex}

\subsection{Collision between particles}

The collision constraint between two particles $ \mathbf{x}_{i} $ and $ \mathbf{x}_{j} $ is formulated by Equation \ref{eq:collisionConstraint}, where the radius of each particle is $ r $. It is commonly solved by translating each particle away from one another along the line $ \| \mathbf{x}_{ij} \| $.

\begin{equation} \label{eq:collisionConstraint}
  C(\mathbf{x}_{i}, \mathbf{x}_{j}) = \| \mathbf{x}_{ij} \| - r \geq 0
\end{equation}

Solving collision constraints between particles by brute force is a very time consuming process, $\mathcal{O}(n^{2})$. As of such developers often look at smarter ways of solving collisions between particles. Due to the fact that particles and other objects for that matter only interact in small regions it is well suited to look at methods involving spatial subdivisions.

\subsubsection{Uniform grid}

One such method that also performs well and is easy to parallelize is the use of a \textit{Uniform Grid} \cite{Green}. A uniform grid implies that the world is composed of a number of cells in a cubical grid, where each cell can store particles. If the cell width equals the diameter of a particle (under the assumption that all particles have the same diameter) collisions only occur between particles of neighbouring cells. This means that only 27 cells per particle needs to be considered in a three dimensional space if the particle collisions are to be solved in a particle based manner. This type of grid is also convenient when solving fluid constraints that originates from the ideas behind \textit{Smoothed-Particle Hydrodynamics} (SPH), as those require all neighbouring particles within a certain distance (defined by the kernel width of \textit{Spiky} and \textit{Poly} kernels).

\subsubsection{Collision with objects}

By transforming the geometry of an object to a particle representation and adding shape matching constraints too hold the particles together one can also have collisions with arbitrary objects \cite{muller2005meshless, macklin2014unified}. The process of creating a particle representation of an object is called \textit{Voxelization} and there exist various methods for achieving this, e.g. \cite{VoxPolygon, VoxSingle}. Some methods build \textit{Occtrees} to be be used for querying occupied \textit{Voxels} while other methods derive the particle representation from ray-casting \cite{VoxSingle}. Performance wise it is suitable to perform the Voxelization of objects prior to the start of the simulation.


\subsection{Density}

The estimation of the predicted position of the particles is initially based on solving a density constraint $C$ in (REF NIKLAS?). Where each density constraint is applied per particle. The density constraint is a function of the position of the current particle and the positions of its neighbours within a fixed radius. For each particle \textit{i}, the applied density constraint is defined as equation \ref{eq:Ci}

\begin{equation}
\label{eq:Ci}
C_i(\hat{\mathbf{p}}) = \frac{\rho_i}{\rho_0} - 1,
\end{equation}
\\
where $\hat{\mathbf{p}}$ contains the positions of the neighbouring particles, $\rho_0$ is the fluid's rest density and $\rho_i$ is estimated by the density SPH estimator:

\begin{equation}
\label{eq:Rhoi}
\rho_i = \sum\limits_{j} m_j W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

In this particular case, where all particles have equal mass, the mass parameter $m_j$ can be removed from $\ref{eq:Rhoi}$. What is left is a sum of density kernels $W$, also called \textit{Poly6}, see \cite{macklin2013position}. Where $W$ is a kernel function with the parameters; the position of the current particle  $i$, neighbouring positions $j$ and a fixed radius $h$.
\\
The next term to be solved from equation (NIKLAS REF?) is $\nabla C$. It is done by following \cite{macklin2013position} approach and has two different outcomes based on whenever particle $k$ is a neighbouring particle or not:
\\
\begin{equation}
 \nabla \mathbf{p}_k C_i = \frac{1}{\rho_0}
  \begin{cases}
  \label{eq:NablaC}
   \displaystyle \sum\limits_{j} \nabla \mathbf{p}_k W(\mathbf{p}_i - \mathbf{p}_j, h) & $\text{if }$ k = i \\
   - \nabla \mathbf{p}_k W(\mathbf{p}_i - \mathbf{p}_j, h) & $\text{if }$ k = j \\
  \end{cases}
\end{equation}
\\
With \ref{eq:Ci} and \ref{eq:NablaC} it is now possible to determine $\lambda$ from equation (NIKLAS REF?):

\begin{equation}
\label{eq:Lambda}
\lambda_i = \frac{- C_i(\hat{\mathbf{p}}) }{ \sum\limits_{k} |\nabla \mathbf{p}_k C_i|^2 }
\end{equation}
\\
As seen in $\cite{macklin2013position}$, we can observe that this is not stable when the particles are at the boundary of the smoothing kernel, mainly because of the denominator with the exponents in the kernel function. Therefore a user specified relaxation parameter, $\varepsilon$, is added to (NIKLAS REF?) to add constraint force. The modified version of $\ref{eq:Lambda}$ is given by
\begin{equation}
\label{eq:Lambda}
\lambda_i = \frac{- C_i(\hat{\mathbf{p}}) }{ \sum\limits_{k} |\nabla \mathbf{p}_k C_i|^2 + \varepsilon} .
\end{equation}
We can now include $\lambda_j$ from the neighbouring particles in the estimation of the final position update, $\Delta \mathbf{p}$, given by

\begin{equation}
\label{eq:DeltaP}
\Delta \mathbf{p}_i = \frac{1}{\rho_0} \sum\limits_{j} (\lambda_i + \lambda_j) \nabla W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

\subsection{Tensile instability}
We continue to follow the work at \cite{macklin2013position}, by adding an artificial pressure to reduce particle splitting behaviour. The negative pressure tends to result into particle clustering and sometimes hard coupling, which is a common problem in SPH simulations. The trick is therefore to force the pressure to be non-negative, with following drawback; a reduction of the particles' cohesiveness. The artificial pressure force is described as
\\
\begin{equation}
\label{eq:DeltaP}
s_{corr} = -k \left( \frac{W(\mathbf{p}_i - \mathbf{p}_j, h)}{W(\Delta \mathbf{q}, h)} \right).
\end{equation}
\\
Where $\Delta \mathbf{q}$ is a point with a fixed distance inside the kernel radius and k is a small positive constant. This term is then included in the equation $\ref{eq:DeltaP}$ and the final version is updated to

\begin{equation}
\label{eq:DeltaP}
\Delta \mathbf{p} = \frac{1}{\rho_0} \sum\limits_{j} (\lambda_i + \lambda_j + s_{corr}) \nabla W(\mathbf{p}_i - \mathbf{p}_j, h).
\end{equation}

\subsection{Vorticity and Viscosity}















